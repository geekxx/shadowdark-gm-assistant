#!/Users/jeffrey.heinen/projects/shadowdark-gm/.venv/bin/python

"""
Shadowdark GM CLI Tool

Command-line interface for the Shadowdark GM Assistant.
Usage:
    gm session summarize input.md --out notion
    gm session summarize transcript.txt --campaign 1 --use-rag
    gm session summarize audio.wav --campaign 1 --out notion
    gm rag ingest rules.pdf --doctype rule
    gm rag query "How do spells work?"
"""

import argparse
import sys
import os
from pathlib import Path
from typing import Optional

# Add the project root to Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from sqlmodel import create_engine, Session
from dotenv import load_dotenv

from core.agents.session_scribe import summarize_text, summarize_audio
from core.agents.rag_librarian import ingest_text, ingest_file, search
from core.data.models import SQLModel
from core.integrations.notion_sync import NotionSync

load_dotenv()

# Database setup
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg://postgres:postgres@localhost:5432/shadowdark")
engine = create_engine(DATABASE_URL, pool_pre_ping=True)

def read_file_content(file_path: str) -> str:
    """Read content from a file"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return ""

def write_file_content(file_path: str, content: str):
    """Write content to a file"""
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"‚úÖ Output written to {file_path}")
    except Exception as e:
        print(f"‚ùå Error writing file {file_path}: {e}")

def handle_session_output(args, notes):
    """Handle session output to various destinations"""
    if args.out == "stdout":
        print("\n" + "="*50)
        print(notes)
        print("="*50)
    elif args.out == "notion":
        # Sync to Notion
        print("üìù Syncing to Notion...")
        try:
            notion = NotionSync()
            
            # Test connection first
            if not notion.test_connection():
                print("‚ùå Failed to connect to Notion. Check your NOTION_TOKEN.")
                print("   Saving to file instead...")
                write_file_content("session_notes.md", notes)
                return
            
            # Create the page
            page_url = notion.create_session_page(
                title=f"Session Notes - {Path(args.input).stem}",
                content=notes,
                properties={
                    "Play Group": {"select": {"name": getattr(args, 'play_group', 'Online')}}
                }
            )
            
            if page_url:
                print(f"‚úÖ Session notes created in Notion: {page_url}")
            else:
                print("‚ùå Failed to create Notion page. Saving to file instead...")
                write_file_content("session_notes.md", notes)
            
        except Exception as e:
            print(f"‚ùå Error syncing to Notion: {e}")
            print("   Saving to file instead...")
            write_file_content("session_notes.md", notes)
    else:
        # Save to file
        write_file_content(args.out, notes)
    
    print("‚úÖ Session summarization completed!")

def cmd_session_summarize(args):
    """Handle session summarize command"""
    if not os.path.exists(args.input):
        print(f"‚ùå Input file not found: {args.input}")
        return
    
    # Check if input is an audio file
    audio_extensions = {'.wav', '.mp3', '.m4a', '.flac', '.ogg'}
    input_path = Path(args.input)
    is_audio = input_path.suffix.lower() in audio_extensions
    
    if is_audio:
        print(f"üéôÔ∏è  Processing audio file: {args.input}")
        return cmd_session_audio_summarize(args)
    else:
        print(f"üìù Summarizing session from text file: {args.input}")
        
        # Read input file
        transcript = read_file_content(args.input)
        if not transcript.strip():
            print("‚ùå Input file is empty")
            return
        
        # Get RAG context if requested
        context_chunks = []
        if args.use_rag:
            print("üîç Gathering relevant context from knowledge base...")
            with Session(engine) as sess:
                # Use first few lines of transcript as search query
                search_query = transcript[:500]
                chunks = search(sess, search_query, k=3)
                context_chunks = [chunk.text for chunk in chunks]
                print(f"   Found {len(context_chunks)} relevant chunks")
        
        # Generate session notes
        print("ü§ñ Generating session notes...")
        try:
            with Session(engine) as sess:
                notes = summarize_text(
                    transcript, 
                    campaign_id=args.campaign,
                    context_chunks=context_chunks if context_chunks else None,
                    db_session=sess if args.save_to_db else None,
                    use_mock=not bool(os.getenv("OPENAI_API_KEY", "").startswith("sk-"))
                )
            
            # Handle output
            handle_session_output(args, notes)
            
        except Exception as e:
            print(f"‚ùå Error generating session notes: {e}")

def cmd_session_audio_summarize(args):
    """Handle audio session summarize command"""
    print(f"üéôÔ∏è  Processing audio session: {args.input}")
    
    # Get RAG context if requested
    context_chunks = []
    if args.use_rag:
        print("üîç Gathering relevant context from knowledge base...")
        with Session(engine) as sess:
            # Use audio filename as search query for initial context
            search_query = f"session audio recording {Path(args.input).stem}"
            chunks = search(sess, search_query, k=3)
            context_chunks = [chunk.text for chunk in chunks]
            print(f"   Found {len(context_chunks)} relevant chunks")
    
    # Generate session notes from audio
    print("ü§ñ Processing audio and generating session notes...")
    try:
        huggingface_token = os.getenv("HUGGINGFACE_TOKEN")
        if not huggingface_token:
            print("‚ö†Ô∏è  No HUGGINGFACE_TOKEN found. You may need to set this to access diarization models.")
        
        with Session(engine) as sess:
            notes = summarize_audio(
                audio_path=args.input,
                campaign_id=args.campaign,
                context_chunks=context_chunks if context_chunks else None,
                db_session=sess if args.save_to_db else None,
                huggingface_token=huggingface_token,
                use_mock=not bool(os.getenv("OPENAI_API_KEY", "").startswith("sk-"))
            )
        
        # Handle output (same as text processing)
        handle_session_output(args, notes)
        
    except Exception as e:
        print(f"‚ùå Error processing audio: {e}")
        if "gated repo" in str(e).lower() or "access" in str(e).lower():
            print("\nüí° To enable audio processing:")
            print("1. Visit: https://huggingface.co/pyannote/speaker-diarization-community-1")
            print("2. Click 'Agree and access repository'")
            print("3. Create a token at: https://huggingface.co/settings/tokens")
            print("4. Set HUGGINGFACE_TOKEN environment variable")

def cmd_rag_ingest(args):
    """Handle RAG ingest command"""
    if not os.path.exists(args.file):
        print(f"‚ùå File not found: {args.file}")
        return
    
    print(f"üìö Ingesting document: {args.file}")
    
    try:
        with Session(engine) as sess:
            doc_id = ingest_file(
                sess, 
                args.file, 
                title=args.title,
                doctype=args.doctype
            )
            print(f"‚úÖ Document ingested successfully with ID: {doc_id}")
    except Exception as e:
        print(f"‚ùå Error ingesting document: {e}")

def cmd_rag_query(args):
    """Handle RAG query command"""
    print(f"üîç Searching knowledge base for: {args.query}")
    
    try:
        with Session(engine) as sess:
            chunks = search(sess, args.query, k=args.k)
            
        if not chunks:
            print("‚ùå No results found")
            return
        
        print(f"üìö Found {len(chunks)} relevant chunks:")
        print("=" * 50)
        
        for i, chunk in enumerate(chunks, 1):
            print(f"\n{i}. Relevance: {chunk.similarity:.3f}")
            print(f"   Document: {chunk.document.title}")
            print(f"   Type: {chunk.document.doctype}")
            if chunk.section:
                print(f"   Section: {chunk.section}")
            
            # Show first 200 chars of content
            preview = chunk.text[:200].replace('\n', ' ')
            if len(chunk.text) > 200:
                preview += "..."
            print(f"   Content: {preview}")
        
        print("=" * 50)
        
    except Exception as e:
        print(f"‚ùå Error querying knowledge base: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="Shadowdark GM Assistant CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s session summarize transcript.txt
  %(prog)s session summarize audio.wav --campaign 1 --use-rag --out notion
  %(prog)s session summarize notes.md --campaign 1 --use-rag --out session_notes.md
  %(prog)s rag ingest shadowdark_rules.pdf --doctype rule
  %(prog)s rag query "How do death saves work?"
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Session commands
    session_parser = subparsers.add_parser('session', help='Session management')
    session_subparsers = session_parser.add_subparsers(dest='session_cmd')
    
    # Session summarize
    summarize_parser = session_subparsers.add_parser('summarize', help='Generate session notes from transcript or audio')
    summarize_parser.add_argument('input', help='Input file (transcript, audio, notes, etc.)')
    summarize_parser.add_argument('--out', default='stdout', 
                                  help='Output destination: stdout, notion, or filename (default: stdout)')
    summarize_parser.add_argument('--campaign', type=int, help='Campaign ID for database storage')
    summarize_parser.add_argument('--use-rag', action='store_true', 
                                  help='Use RAG to include relevant context from knowledge base')
    summarize_parser.add_argument('--save-to-db', action='store_true',
                                  help='Save session data to database')
    summarize_parser.add_argument('--play-group', choices=['Post 161', 'Online'], 
                                  default='Online', help='Play group for Notion (default: Online)')
    
    # RAG commands
    rag_parser = subparsers.add_parser('rag', help='Knowledge base management')
    rag_subparsers = rag_parser.add_subparsers(dest='rag_cmd')
    
    # RAG ingest
    ingest_parser = rag_subparsers.add_parser('ingest', help='Add documents to knowledge base')
    ingest_parser.add_argument('file', help='File to ingest (PDF, Markdown, or text)')
    ingest_parser.add_argument('--title', help='Document title (defaults to filename)')
    ingest_parser.add_argument('--doctype', choices=['rule', 'note', 'transcript', 'compendium', 'other'],
                               help='Document type')
    
    # RAG query
    query_parser = rag_subparsers.add_parser('query', help='Search knowledge base')
    query_parser.add_argument('query', help='Search query')
    query_parser.add_argument('--k', type=int, default=5, help='Number of results to return')
    
    args = parser.parse_args()
    
    if args.command == 'session':
        if args.session_cmd == 'summarize':
            cmd_session_summarize(args)
        else:
            session_parser.print_help()
    elif args.command == 'rag':
        if args.rag_cmd == 'ingest':
            cmd_rag_ingest(args)
        elif args.rag_cmd == 'query':
            cmd_rag_query(args)
        else:
            rag_parser.print_help()
    else:
        parser.print_help()

if __name__ == '__main__':
    main()